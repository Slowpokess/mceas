# MCEAS - Протоколы коммуникации

## Обзор

Модуль коммуникаций MCEAS обеспечивает надежный и безопасный обмен данными между агентом и сервером. Система поддерживает несколько протоколов, которые могут динамически выбираться в зависимости от условий сети и требований безопасности.

## Архитектура коммуникаций

### Компоненты коммуникационной системы

- **Client** - отвечает за установление соединения с сервером
- **Connection** - управляет состоянием соединения и параметрами
- **Message** - базовый формат обмена данными
- **Protocols** - конкретные реализации протоколов коммуникации

Система использует паттерн "Фабрика" для создания экземпляров протоколов:

```cpp
class ProtocolFactory {
public:
    using ProtocolCreator = std::function<std::unique_ptr<ProtocolBase>()>;
    
    static void registerProtocol(const std::string& name, ProtocolCreator creator);
    static std::unique_ptr<ProtocolBase> createProtocol(const std::string& name);
    
private:
    static std::map<std::string, ProtocolCreator> registry_;
};
```

### Базовый интерфейс протоколов

Все протоколы реализуют общий интерфейс:

```cpp
class ProtocolBase {
public:
    virtual ~ProtocolBase() = default;
    
    virtual bool connect(const ProtocolConfig& config) = 0;
    virtual bool disconnect() = 0;
    virtual ConnectionState getConnectionState() const = 0;
    
    virtual bool send(const Message& message) = 0;
    virtual std::optional<Message> receive() = 0;
    virtual std::optional<Message> sendAndWaitForResponse(const Message& message, 
                                                       int timeout_ms = 30000) = 0;
};
```

## Реализованные протоколы

### HTTP/HTTPS протокол

HTTP/HTTPS протокол реализует механизм обмена данными поверх стандартного HTTP. Особенности:

#### Механизмы надежности

- **Автоматические повторные попытки** - при сетевых ошибках или таймаутах запросы повторяются с экспоненциальной задержкой
- **Отказоустойчивость** - автоматическое восстановление соединения при сбоях
- **Обработка ошибок** - детальная информация о причинах сбоев для диагностики

#### Оптимизация производительности

- **Сжатие данных** - использование gzip/zlib для уменьшения размера передаваемых данных
- **Чанкинг (chunking)** - разбиение больших сообщений на части для эффективной передачи
- **Пулинг соединений** - повторное использование установленных соединений

#### Меры безопасности

- **Маскирование трафика** - запросы маскируются под обычный браузерный трафик:
  - User-Agent: соответствует популярным браузерам
  - Поддержка стандартных заголовков
  - Имитация паттернов обычного веб-серфинга

- **Шифрование данных** - многоуровневое шифрование:
  - TLS для защиты канала передачи
  - Дополнительное шифрование полезной нагрузки

- **Обход блокировок** - механизмы для обхода фильтрации и блокировок:
  - Динамическая смена доменов
  - Поддержка прокси-серверов

### DNS over HTTPS (DoH) протокол

DoH протокол обеспечивает защищенные DNS-запросы и может использоваться в качестве вторичного канала коммуникации.

#### Особенности DoH протокола:

- **Маскирование DNS-запросов** - DNS-запросы шифруются и передаются через HTTPS
- **Использование стандартных портов** - все коммуникации идут через порт 443, что затрудняет блокировку
- **Совместимость с стандартами** - использование RFC 8484 для совместимости с существующими DoH-серверами
- **Возможность туннелирования** - передача произвольных данных внутри DNS-запросов

#### Применение DoH в MCEAS:

- **Резервный канал связи** - при блокировке основного HTTP/HTTPS канала
- **Обнаружение серверов** - получение актуальных адресов C2-серверов через защищенные DNS-запросы
- **Передача небольших команд** - управление агентом через DNS-запросы при недоступности основного канала

## Формат сообщений

### Базовая структура сообщения

```cpp
struct Message {
    std::string message_id;
    std::string agent_id;
    MessageType type;
    std::map<std::string, std::string> headers;
    std::vector<uint8_t> payload;
    uint64_t timestamp;
    
    std::vector<uint8_t> serialize() const;
    static Message deserialize(const std::vector<uint8_t>& data);
};
```

### Типы сообщений

- **HEARTBEAT** - проверка работоспособности соединения
- **TELEMETRY** - передача телеметрических данных от агента к серверу
- **COMMAND** - команда от сервера к агенту
- **RESPONSE** - ответ агента на команду
- **CONFIG** - передача конфигурации между агентом и сервером
- **UPDATE** - сообщение для управления обновлениями агента

### Режимы передачи

- **Синхронный** - блокирующее ожидание ответа на запрос
- **Асинхронный** - отправка сообщений без ожидания ответа
- **Отложенный** - сохранение сообщений при отсутствии соединения с последующей отправкой

## Механизмы обеспечения надежности

### Повторные попытки с экспоненциальной задержкой

При сетевых ошибках система автоматически повторяет попытки с увеличивающимися интервалами:

```cpp
static int calculateRetryDelayMs(int attempt) {
    // Экспоненциальный откат с небольшой случайностью
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> jitter(-200, 200);
    
    int delay = BASE_RETRY_DELAY_MS * (1 << attempt) + jitter(gen);
    return std::min(delay, MAX_RETRY_DELAY_MS);
}
```

### Работа с большими сообщениями

Сообщения, превышающие определенный размер, автоматически разбиваются на части (чанки):

```cpp
bool HttpProtocol::sendChunkedMessage(const Message& message, size_t chunk_size) {
    // Разбиваем данные на части и отправляем последовательно
    // Каждый чанк содержит метаданные для последующей сборки
    // ...
}
```

### Механизм сжатия данных

Для оптимизации трафика используется сжатие больших сообщений:

```cpp
// Сжатие данных с использованием zlib
static std::vector<uint8_t> compressData(const std::vector<uint8_t>& data) {
    if (data.size() < MIN_COMPRESSION_SIZE) {
        // Не сжимаем маленькие данные
        return data;
    }
    
    // Используем zlib для сжатия
    // ...
}
```

## Безопасность коммуникаций

### Шифрование

- **Транспортный уровень**: TLS 1.2/1.3 для HTTPS соединений
- **Прикладной уровень**: Собственная система шифрования для защиты содержимого сообщений

### Защита от обнаружения

- **Стеганография**: Скрытие коммуникаций внутри обычного трафика
- **Имитация браузера**: Использование заголовков и паттернов запросов, характерных для браузеров

### Отказоустойчивость

- **Резервные серверы**: Поддержка списка резервных серверов для случаев недоступности основного
- **Резервные каналы**: Возможность переключения между протоколами при обнаружении блокировок

## Примеры использования

### Инициализация и настройка протокола

```cpp
// Создание экземпляра протокола через фабрику
auto protocol = ProtocolFactory::createProtocol("https");

// Настройка параметров подключения
ProtocolConfig config;
config.endpoint = "example.com";
config.port = 443;
config.timeout_ms = 30000;
config.retry_count = 5;
config.use_encryption = true;

// Подключение
protocol->connect(config);
```

### Отправка сообщения

```cpp
// Создание сообщения
Message message;
message.message_id = generateUniqueId();
message.agent_id = getAgentId();
message.type = MessageType::TELEMETRY;
message.timestamp = getCurrentTimestamp();
message.payload = collectTelemetryData();

// Отправка
if (protocol->send(message)) {
    // Успешно отправлено
} else {
    // Обработка ошибки
}
```

### Ожидание ответа

```cpp
// Отправка команды и ожидание ответа
Message command = createCommand("get_browser_data");
auto response = protocol->sendAndWaitForResponse(command, 60000);

if (response) {
    // Обработка ответа
    processBrowserData(response->payload);
} else {
    // Обработка таймаута или ошибки
}
```